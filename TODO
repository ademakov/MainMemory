
ASAP:
* cross-core wait/signal mechanism
* socket distribution among cores
* let futures run on other cores
* let ports work across cores
* memcache module enhancements:
** use socket distribution
** use futures for commands
** implement expiration
** polish & optimize

;;; At this point it becomes usable in simple cases and ready for benchmarks
;;; against stock memcache.

Essentials:
* configuration file parsing
* command line argument parsing
* support signals
* system call threads
* resolve socket close issues: time wait
* disk I/O threads
* syslog
* daemonize
* statistics
* UDP servers
* SSL servers
* DNS resolver
* performance instrumentation
* use non-blocking data structures instead of locks where possible
* refine memcache module:
** statistics
** add UDP protocol support
** add binary protocol support
* correct object destruction and graceful shutdown:
** ensure worker & master & aux tasks are finished on shutdown
** ensure destroyed socket & server objects are not accessed anymore
** ensure safe task & port objects destruction
** refcount? capabilities? some form of SMR?

Larger items:
* HTTP module
* persistence
* replication
* extension language

Enhancements:
* fs event notification
* task local storage (tls)
* reap dead tasks pending for too long
* try to detect clock adjustments and reset realtime timers accordingly
* memory management:
** use separate mspace for task local dynamic memory ?
** slab allocator (to base object pools on)
** buddy allocator (for I/O buffers and slabs)
** region allocator
** garbage collection
* failure trace records
* arm port
