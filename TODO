
ASAP:
* devise generic net buffer mechanism
* worker threads, multi-threaded task & work schedulers
* network input handling now takes the following path:
  event-loop task -> net I/O task -> master task -> worker (reader) task
  Then transmitting the response might take he following path:
  worker (reader) task -> net I/O task (mm_net_spawn_writer) -> master task -> worker (writer) task
  Test the performance of this lengthy path and optimize if needed.
* correct shutdown:
** ensure worker & master & aux tasks are finished
** ensure socket & server object destruction
* correct destruction:
** ensure destroyed socket & server objects are not accessed anymore
** ensure safe task & port objects destruction (refcount? capabilities?)

Essentials:
* use non-blocking data structures instead of locks where possible
* resolve socket close issues: time wait
* support signals
* UDP servers
* SSL servers
* fs notifications
* system call threads
* disk I/O threads
* configuration file parsing
* command line argument parsing
* syslog
* daemonize
* statistics
* performance instrumentation
* refine and finish memcache module:
** eviction
** expiration
** statistics
** polish
** optimize
** add UDP protocol support
** add binary protocol support
** use multi-threaded workers
* HTTP module

Enhancements:
* task local storage (tls)
* reap dead tasks pending for too long
* try to detect clock adjustments and reset realtime timers accordingly
* memory management:
** use separate mspace for task local dynamic memory ?
** slab allocator (to base object pools on)
** buddy allocator (for I/O buffers and slabs)
** region allocator
** garbage collection
* failure trace records
* arm port
